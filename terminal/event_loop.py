import asyncio
from dataclasses import dataclass
from pathlib import Path
from types import ModuleType
from typing import Any, AsyncGenerator, Optional, Union, cast

import src
import thrift_ffi
import target.debug
import target.debug.deps
from cffi import FFI
from pants.util.contextutil import temporary_file
from pkg_resources import DefaultProvider, ZipProvider, get_provider
from thrift.transport.TTransport import TTransportBase


def get_resource_string(module: ModuleType, rel_path: Path) -> bytes:
  # This technique was taken from pex/pex_builder.py in the pex repo.
  provider: Any = get_provider(module.__name__)
  if not isinstance(provider, DefaultProvider):
    mod = __import__(module.__name__, fromlist=['ignore'])
    provider = ZipProvider(mod)  # type: ignore[call-arg]
  provider: Union[DefaultProvider, ZipProvider] = provider  # type: ignore[no-redef]

  return cast(bytes, provider.get_resource_string(module.__name__, str(rel_path)))


def open_dylib_resource(ffi: FFI, dylib: bytes):
  with temporary_file() as f:
    f.write(dylib)
    f.flush()
    return ffi.dlopen(f.name)


def bootstrap_thrift_ffi() -> FFI:
  ffi = FFI()

  # Load the rust cdylib for the bindings.
  terminal_wrapper_lib = open_dylib_resource(
    ffi,
    get_resource_string(target.debug, Path('libterminal_wrapper.dylib')))
  terminal_wrapper_bindings = get_resource_string(
    src,
    Path('terminal_wrapper_bindings.h'),
  ).decode('utf-8')
  ffi.cdef(terminal_wrapper_bindings)

  # Load the header file for the bindings. These will be contained in two separate header files, one
  # for the base "thrift_ffi" package, then one generated by the "terminal-wrapper" package.
  thrift_ffi_lib = open_dylib_resource(
    ffi,
    get_resource_string(target.debug.deps, Path('libthrift_ffi.dylib')))
  thrift_ffi_base_bindings = get_resource_string(
    thrift_ffi,
    Path('thrift_ffi_bindings.h')
  ).decode('utf-8')
  ffi.cdef(thrift_ffi_base_bindings)

  return ffi, thrift_ffi_lib, terminal_wrapper_lib


class FFIBidiTransport(TTransportBase):

  # NB: The `lib` should be from 'libthrift_ffi.dylib'!!!
  def __init__(self, ffi, lib):
    self._handle = None
    self._ffi = ffi
    self._lib = lib
    self._is_open = False

  def isOpen(self):
    return self._is_open

  def open(self):
    assert not self._is_open

    with self._ffi.new('ClientRequest*') as request,\
         self._ffi.new('ClientCreationResult*') as result:
      request.tag = lib.Monocast
      request.monocast = 300
      lib.create_thrift_ffi_client(request, result)
      assert result.tag == ffi.Created
      self._handle = result.created.tup_0
    self._is_open = True

  def close(self):
    if not self._is_open:
      return

    assert self._lib.destroy_thrift_ffi_client(self._handle).tag == self._lib.SuccessfullyFreed
    self._is_open = False

  def read(self, sz):
    assert self._is_open
    with self._ffi.new('char[]', sz) as cur_buf,\
         self._ffi.new('ThriftReadResult*') as result:

      chunk = self._lib.ThriftChunk()
      chunk.ptr = cur_buf
      chunk.len = len(cur_buf)
      chunk.capacity = len(cur_buf)

      self._lib.read_buffer_handle(self._handle, chunk, result)
      assert result.tag == self._lib.Read
      assert result.read <= chunk.len

      return chunk.ptr[:result.read]

  def readAll(self, sz):
    buff = b''
    have = 0
    while have < sz:
      chunk = self.read(sz - have)
      chunkLen = len(chunk)
      have += chunkLen
      buff += chunk

      if chunkLen == 0:
        raise EOFError()

    return buff

  def write(self, buf):
    assert self._is_open
    with self._ffi.from_buffer(buf) as cur_buf,\
         self._ffi.new('ThriftWriteResult*') as result:

      chunk = self._lib.ThriftChunk()
      chunk.ptr = cur_buf
      chunk.len = len(buf)
      chunk.capacity = len(buf)

      self._lib.write_buffer_handle(self._handle, chunk, result)

      assert result.tag == self._lib.Written
      return result.written

  def flush(self):
    pass


# async def event_loop() -> AsyncGenerator[TerminalEvent]:
#   yield 3


def main() -> None:
  print('hello!')
  ffi, thrift_ffi_lib, terminal_wrapper_lib = bootstrap_thrift_ffi()
  with ffi.new('ClientRequest*') as request,\
       ffi.new('ClientCreationResult*') as result:
    request.tag = thrift_ffi_lib.Monocast
    request.monocast = (300,)
    thrift_ffi_lib.create_thrift_ffi_client(request, result)
    assert result.tag == thrift_ffi_lib.Created
    thrift_buffer_handle = result.created.tup_0
  print(f'thrift_buffer_handle = {thrift_buffer_handle}')
  assert thrift_ffi_lib.destroy_thrift_ffi_client(thrift_buffer_handle) == thrift_ffi_lib.SuccessfullyFreed
