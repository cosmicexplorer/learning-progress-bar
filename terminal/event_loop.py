import asyncio
from dataclasses import dataclass
from pathlib import Path
from types import ModuleType
from typing import Any, AsyncGenerator, Optional, Union, cast

from cffi import FFI
from pants.util.contextutil import temporary_file
from pkg_resources import DefaultProvider, ZipProvider, get_provider
from thrift.protocol.TBinaryProtocol import TBinaryProtocol
from thrift.transport.TTransport import TTransportBase

import generated_headers
import target.debug

from terminal.streaming_interface import TerminalWrapper
from terminal.streaming_interface.constants import *
from terminal.streaming_interface.ttypes import *


def get_resource_string(module: ModuleType, rel_path: Path) -> bytes:
  # This technique was taken from pex/pex_builder.py in the pex repo.
  provider: Any = get_provider(module.__name__)
  if not isinstance(provider, DefaultProvider):
    mod = __import__(module.__name__, fromlist=['ignore'])
    provider = ZipProvider(mod)  # type: ignore[call-arg]
  provider: Union[DefaultProvider, ZipProvider] = provider  # type: ignore[no-redef]

  return cast(bytes, provider.get_resource_string(module.__name__, str(rel_path)))


def open_dylib_resource(ffi: FFI, dylib: bytes):
  with temporary_file() as f:
    f.write(dylib)
    f.flush()
    return ffi.dlopen(f.name)


def bootstrap_thrift_ffi() -> FFI:
  ffi = FFI()

  # Load the header files for the bindings. These will be contained in two separate header files,
  # one for the base "thrift-ffi" package, then one generated by the "terminal-wrapper" package.
  thrift_ffi_base_bindings = get_resource_string(
    generated_headers,
    Path('thrift-ffi-bindings.h')
  ).decode('utf-8')
  ffi.cdef(thrift_ffi_base_bindings)

  terminal_wrapper_bindings = get_resource_string(
    generated_headers,
    Path('terminal-wrapper-bindings.h'),
  ).decode('utf-8')
  ffi.cdef(terminal_wrapper_bindings)

  lib = open_dylib_resource(
    ffi,
    get_resource_string(target.debug, Path('libterminal_wrapper.dylib')))

  return ffi, lib


class FFIMonocastTransport(TTransportBase):

  def __init__(self, ffi, lib, read_capacity, write_capacity):
    self._handle = None
    self._ffi = ffi
    self._lib = lib
    self._read_capacity = read_capacity
    self._write_capacity = write_capacity
    self._is_open = False

    self._mutable_chunk = None
    self._max_cap = max(self._read_capacity, self._write_capacity)

    self._cur_read_result = None
    self._cur_write_result = None

  def isOpen(self):
    return self._is_open

  def open(self):
    assert not self._is_open

    with self._ffi.new('ClientRequest*') as request,\
         self._ffi.new('ClientCreationResult*') as result:
      request.tag = self._lib.Monocast
      monocast = dict(
        read_capacity=self._read_capacity,
        write_capacity=self._write_capacity,
      )
      request.monocast = (monocast,)
      self._lib.create_thrift_ffi_client(request, result)
      assert result.tag == self._lib.Created
      self._handle = result.created.tup_0

    self._mutable_chunk = self._ffi.new('ThriftChunk*')
    self._mutable_chunk = dict(
      ptr=self._ffi.new('char[]', self._max_cap),
      len=0,
      capacity=self._max_cap,
    )

    self._cur_read_result = self._ffi.new('ThriftReadResult*')
    self._cur_write_result = self._ffi.new('ThriftWriteResult*')

    self._is_open = True

  def close(self):
    if not self._is_open:
      return

    self._ffi.release(self._mutable_chunk.ptr)
    self._ffi.release(self._mutable_chunk)
    self._mutable_chunk = None

    self._ffi.release(self._cur_read_result)
    self._cur_read_result = None

    self._ffi.release(self._cur_write_result)
    self._cur_write_result = None

    assert self._lib.destroy_thrift_ffi_client(self._handle).tag == self._lib.SuccessfullyFreed
    self._is_open = False

  def _maybe_expand_chunk(self, sz):
    if sz <= self._mutable_chunk.capacity:
      return

    self._max_cap = sz

    self._ffi.release(self._mutable_chunk.ptr)
    self._mutable_chunk = dict(
      ptr=self._ffi.new('char[]', self._max_cap),
      len=0,
      capacity=self._max_cap,
    )

  def read(self, sz):
    assert self._is_open

    self._maybe_expand_chunk(sz)

    self._mutable_chunk.len = sz

    result = self._cur_read_result
    self._lib.read_buffer_handle(self._handle, chunk, result)
    assert result.tag == self._lib.Read
    assert result.read <= sz

    return self._ffi.buffer(self._mutable_chunk.ptr, result.read)[:]

  def write(self, buf):
    assert self._is_open

    self._maybe_expand_chunk(len(buf))

    self._mutable_chunk.ptr[0:len(buf)] = buf
    self._mutable_chunk.len = len(buf)

    result = self._cur_write_result
    self._lib.write_buffer_handle(self._handle, chunk, result)
    assert result.tag == self._lib.Written

    return result.written

  def flush(self):
    # An in-memory buffer has no flush step -- see the docs for the rust TBufferChannel (which this
    # uses) flush() at
    # https://github.com/apache/thrift/blob/master/lib/rs/src/transport/mem.rs#L183-L185!
    pass


# async def event_loop() -> AsyncGenerator[TerminalEvent]:
#   yield 3


def main() -> None:
  print('hello!')

  ffi, lib = bootstrap_thrift_ffi()

  # transport = FFIMonocastTransport(ffi, lib, 300, 300)
  # protocol = TBinaryProtocol(transport)
  # client = TerminalWrapper.Client(protocol)

  with ffi.new('UserRequest*') as request:
    result = lib.create_user(request)
    assert result.tag == lib.Created
    user_handle = result.created.tup_0
  print(f'user_handle = {user_handle}')

  result = lib.destroy_thrift_ffi_client(user_handle)
  assert result.tag == lib.Succeeded
